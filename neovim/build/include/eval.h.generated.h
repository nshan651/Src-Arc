#define DEFINE_FUNC_ATTRIBUTES
#include "nvim/func_attr.h"
#undef DEFINE_FUNC_ATTRIBUTES
#ifndef DLLEXPORT
#  ifdef MSWIN
#    define DLLEXPORT __declspec(dllexport)
#  else
#    define DLLEXPORT
#  endif
#endif
DLLEXPORT dict_T *get_v_event(save_v_event_T *sve);
DLLEXPORT void restore_v_event(dict_T *v_event, save_v_event_T *sve);
DLLEXPORT varnumber_T num_divide(varnumber_T n1, varnumber_T n2) FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT varnumber_T num_modulus(varnumber_T n1, varnumber_T n2) FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT void eval_init(void);
DLLEXPORT void set_internal_string_var(const char *name, char *value) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT int var_redir_start(char *name, int append);
DLLEXPORT void var_redir_str(const char *value, int value_len);
DLLEXPORT void var_redir_stop(void);
DLLEXPORT int eval_charconvert(const char *const enc_from, const char *const enc_to, const char *const fname_from, const char *const fname_to);
DLLEXPORT void eval_diff(const char *const origfile, const char *const newfile, const char *const outfile);
DLLEXPORT void eval_patch(const char *const origfile, const char *const difffile, const char *const outfile);
DLLEXPORT int eval_to_bool(char *arg, _Bool *error, char **nextcmd, int skip);
DLLEXPORT _Bool eval_expr_valid_arg(const typval_T *const tv) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_CONST;
DLLEXPORT int eval_expr_typval(const typval_T *expr, typval_T *argv, int argc, typval_T *rettv) FUNC_ATTR_NONNULL_ARG(1, 2, 4);
DLLEXPORT _Bool eval_expr_to_bool(const typval_T *expr, _Bool *error) FUNC_ATTR_NONNULL_ARG(1, 2);
DLLEXPORT char *eval_to_string_skip(const char *arg, const char **nextcmd, const _Bool skip) FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int skip_expr(char **pp);
DLLEXPORT char *eval_to_string(char *arg, char **nextcmd, _Bool convert);
DLLEXPORT char *eval_to_string_safe(char *arg, char **nextcmd, int use_sandbox);
DLLEXPORT varnumber_T eval_to_number(char *expr);
DLLEXPORT typval_T *eval_expr(char *arg);
DLLEXPORT void list_vim_vars(int *first);
DLLEXPORT void list_script_vars(int *first);
DLLEXPORT _Bool is_vimvarht(const hashtab_T *ht);
DLLEXPORT _Bool is_compatht(const hashtab_T *ht);
DLLEXPORT void prepare_vimvar(int idx, typval_T *save_tv);
DLLEXPORT void restore_vimvar(int idx, typval_T *save_tv);
DLLEXPORT list_T *eval_spell_expr(char *badword, char *expr);
DLLEXPORT int get_spellword(list_T *const list, const char **ret_word);
DLLEXPORT int call_vim_function(const char *func, int argc, typval_T *argv, typval_T *rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *call_func_retstr(const char *const func, int argc, typval_T *argv) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC;
DLLEXPORT void *call_func_retlist(const char *func, int argc, typval_T *argv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int eval_foldexpr(char *arg, int *cp);
DLLEXPORT char *get_lval(char *const name, typval_T *const rettv, lval_T *const lp, const _Bool unlet, const _Bool skip, const int flags, const int fne_flags) FUNC_ATTR_NONNULL_ARG(1, 3);
DLLEXPORT void clear_lval(lval_T *lp);
DLLEXPORT void set_var_lval(lval_T *lp, char *endp, typval_T *rettv, int copy, const _Bool is_const, const char *op);
DLLEXPORT void *eval_for_line(const char *arg, _Bool *errp, char **nextcmdp, int skip);
DLLEXPORT _Bool next_for_item(void *fi_void, char *arg);
DLLEXPORT void free_for_info(void *fi_void);
DLLEXPORT void set_context_for_expression(expand_T *xp, char *arg, cmdidx_T cmdidx) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void del_menutrans_vars(void);
DLLEXPORT char *cat_prefix_varname(int prefix, const char *name) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *get_user_var_name(expand_T *xp, int idx);
DLLEXPORT int pattern_match(const char *pat, const char *text, _Bool ic);
DLLEXPORT int eval0(char *arg, typval_T *rettv, char **nextcmd, int evaluate);
DLLEXPORT int eval1(char **arg, typval_T *rettv, int evaluate);
DLLEXPORT int get_option_tv(const char **const arg, typval_T *const rettv, const _Bool evaluate) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT char *partial_name(partial_T *pt) FUNC_ATTR_PURE;
DLLEXPORT void partial_unref(partial_T *pt);
DLLEXPORT _Bool func_equal(typval_T *tv1, typval_T *tv2, _Bool ic);
DLLEXPORT int get_copyID(void) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool garbage_collect(_Bool testing);
DLLEXPORT _Bool set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT size_t string2float(const char *const text, float_T *const ret_value) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void assert_error(garray_T *gap);
DLLEXPORT void filter_map(typval_T *argvars, typval_T *rettv, int map);
DLLEXPORT void common_function(typval_T *argvars, typval_T *rettv, _Bool is_funcref);
DLLEXPORT linenr_T tv_get_lnum_buf(const typval_T *const tv, const buf_T *const buf) FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT void get_user_input(const typval_T *const argvars, typval_T *const rettv, const _Bool inputdialog, const _Bool secret) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char **tv_to_argv(typval_T *cmd_tv, const char **cmd, _Bool *executable);
DLLEXPORT void return_register(int regname, typval_T *rettv);
DLLEXPORT void screenchar_adjust(ScreenGrid **grid, int *row, int *col);
DLLEXPORT void get_xdg_var_list(const XDGVarType xdg, typval_T *rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv, _Bool retlist);
DLLEXPORT _Bool callback_from_typval(Callback *const callback, const typval_T *const arg) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool callback_call(Callback *const callback, const int argcount_in, typval_T *const argvars_in, typval_T *const rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT _Bool set_ref_in_callback(Callback *callback, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack);
DLLEXPORT timer_T *find_timer_by_nr(varnumber_T xx);
DLLEXPORT void add_timer_info(typval_T *rettv, timer_T *timer);
DLLEXPORT void add_timer_info_all(typval_T *rettv);
DLLEXPORT void timer_due_cb(TimeWatcher *tw, void *data);
DLLEXPORT uint64_t timer_start(const long timeout, const int repeat_count, const Callback *const callback);
DLLEXPORT void timer_stop(timer_T *timer);
DLLEXPORT void timer_stop_all(void);
DLLEXPORT void timer_teardown(void);
DLLEXPORT _Bool write_list(FileDescriptor *const fp, const list_T *const list, const _Bool binary) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT _Bool write_blob(FileDescriptor *const fp, const blob_T *const blob) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT int read_blob(FILE *const fd, typval_T *rettv, off_T offset, off_T size_arg) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, _Bool endnl, _Bool crlf) FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int buf_byteidx_to_charidx(buf_T *buf, linenr_T lnum, int byteidx);
DLLEXPORT int buf_charidx_to_byteidx(buf_T *buf, linenr_T lnum, int charidx);
DLLEXPORT pos_T *var2fpos(const typval_T *const tv, const _Bool dollar_lnum, int *const ret_fnum, const _Bool charcol) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp, _Bool charcol);
DLLEXPORT int get_env_len(const char **arg);
DLLEXPORT int get_id_len(const char **const arg);
DLLEXPORT int get_name_len(const char **const arg, char **alias, _Bool evaluate, _Bool verbose);
DLLEXPORT const char *find_name_end(const char *arg, const char **expr_start, const char **expr_end, int flags);
DLLEXPORT _Bool eval_isnamec(int c);
DLLEXPORT _Bool eval_isnamec1(int c);
DLLEXPORT _Bool eval_isdictc(int c);
DLLEXPORT typval_T *get_vim_var_tv(int idx);
DLLEXPORT varnumber_T get_vim_var_nr(int idx) FUNC_ATTR_PURE;
DLLEXPORT char *get_vim_var_str(int idx) FUNC_ATTR_PURE FUNC_ATTR_NONNULL_RET;
DLLEXPORT list_T *get_vim_var_list(int idx) FUNC_ATTR_PURE;
DLLEXPORT dict_T *get_vim_var_dict(int idx) FUNC_ATTR_PURE;
DLLEXPORT void set_vim_var_char(int c);
DLLEXPORT void set_vcount(long count, long count1, int set_prevcount);
DLLEXPORT void set_vim_var_nr(const VimVarIndex idx, const varnumber_T val);
DLLEXPORT void set_vim_var_bool(const VimVarIndex idx, const BoolVarValue val);
DLLEXPORT void set_vim_var_special(const VimVarIndex idx, const SpecialVarValue val);
DLLEXPORT void set_vim_var_string(const VimVarIndex idx, const char *const val, const ptrdiff_t len);
DLLEXPORT void set_vim_var_list(const VimVarIndex idx, list_T *const val);
DLLEXPORT void set_vim_var_dict(const VimVarIndex idx, dict_T *const val);
DLLEXPORT void set_argv_var(char **argv, int argc);
DLLEXPORT void set_reg_var(int c);
DLLEXPORT char *v_exception(char *oldval);
DLLEXPORT char *v_throwpoint(char *oldval);
DLLEXPORT char *set_cmdarg(exarg_T *eap, char *oldarg);
DLLEXPORT _Bool is_luafunc(partial_T *partial) FUNC_ATTR_PURE;
DLLEXPORT const char *skip_luafunc_name(const char *p) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int check_luafunc_name(const char *const str, const _Bool paren) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int handle_subscript(const char **const arg, typval_T *rettv, int evaluate, int verbose);
DLLEXPORT void set_selfdict(typval_T *const rettv, dict_T *const selfdict);
DLLEXPORT dictitem_T *find_var(const char *const name, const size_t name_len, hashtab_T **htp, int no_autoload);
DLLEXPORT dictitem_T *find_var_in_ht(hashtab_T *const ht, int htname, const char *const varname, const size_t varname_len, int no_autoload) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT hashtab_T *find_var_ht_dict(const char *name, const size_t name_len, const char **varname, dict_T **d);
DLLEXPORT hashtab_T *find_var_ht(const char *name, const size_t name_len, const char **varname);
DLLEXPORT void new_script_vars(scid_T id);
DLLEXPORT void init_var_dict(dict_T *dict, ScopeDictDictItem *dict_var, ScopeType scope);
DLLEXPORT void unref_var_dict(dict_T *dict);
DLLEXPORT int var_item_copy(const vimconv_T *const conv, typval_T *const from, typval_T *const to, const _Bool deep, const int copyID) FUNC_ATTR_NONNULL_ARG(2, 3);
DLLEXPORT void ex_echo(exarg_T *eap);
DLLEXPORT void ex_echohl(exarg_T *eap);
DLLEXPORT void ex_execute(exarg_T *eap);
DLLEXPORT const char *find_option_end(const char **const arg, int *const scope);
DLLEXPORT const void *var_shada_iter(const void *const iter, const char **const name, typval_T *rettv, var_flavour_T flavour) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(2, 3);
DLLEXPORT void var_set_global(const char *const name, typval_T vartv);
DLLEXPORT int store_session_globals(FILE *fd);
DLLEXPORT void last_set_msg(sctx_T script_ctx);
DLLEXPORT void option_last_set_msg(LastSet last_set);
DLLEXPORT void reset_v_option_vars(void);
DLLEXPORT int modify_fname(char *src, _Bool tilde_file, size_t *usedlen, char **fnamep, char **bufp, size_t *fnamelen);
DLLEXPORT char *do_string_sub(char *str, char *pat, char *sub, typval_T *expr, const char *flags);
DLLEXPORT _Bool common_job_callbacks(dict_T *vopts, CallbackReader *on_stdout, CallbackReader *on_stderr, Callback *on_exit);
DLLEXPORT Channel *find_job(uint64_t id, _Bool show_error);
DLLEXPORT void script_host_eval(char *name, typval_T *argvars, typval_T *rettv);
DLLEXPORT typval_T eval_call_provider(char *provider, char *method, list_T *arguments, _Bool discard);
DLLEXPORT _Bool eval_has_provider(const char *feat);
DLLEXPORT void eval_fmt_source_name_line(char *buf, size_t bufsize);
DLLEXPORT void ex_checkhealth(exarg_T *eap);
DLLEXPORT void invoke_prompt_callback(void);
DLLEXPORT _Bool invoke_prompt_interrupt(void);
DLLEXPORT int typval_compare(typval_T *typ1, typval_T *typ2, exprtype_T type, _Bool ic) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *typval_tostring(typval_T *arg, _Bool quotes);
#include "nvim/func_attr.h"
